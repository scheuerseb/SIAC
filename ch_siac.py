# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ch_siac
 Spatial Impact Assessment and Classification
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-07
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Sebastian Scheuer, CLEARING HOUSE project
        email                : sebastian.scheuer@geo.hu-berlin.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from logging.handlers import TimedRotatingFileHandler
from sre_parse import FLAGS

import matplotlib
import matplotlib.backends.backend_qt5agg
matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt

from numpy import DataSource
from math import sqrt, pow, sin, cos, atan, pi
from enum import Enum
from time import sleep
import momepy
import processing
import pandas as pd
import geopandas as geopd
import shapely.wkt
from shapely.geometry import *
from console import console
import statistics as stats
from datetime import datetime
from enum import Enum, EnumMeta
import inspect
import seaborn as sns
from sklearn import linear_model
import statsmodels.api as sm
import uuid
import networkx as nx

import os.path
import xlsxwriter as xlsx
from functools import partial
from typing import Iterable, Dict, Tuple
from qgis.core import *
from qgis.gui import QgsMessageBar, QgsMapLayerComboBox, QgsFieldComboBox, QgsMapToolEmitPoint
from qgis.PyQt.QtCore import Qt, QThread, QSettings, QTranslator, QCoreApplication, QVariant, pyqtSignal, QAbstractTableModel, QModelIndex, QSize
from qgis.PyQt.QtGui import QIcon, QKeySequence
from qgis.PyQt.QtWidgets import QErrorMessage, QLabel, QAction, QMessageBox, QProgressBar, QMenu, QHeaderView, QFileDialog, QDockWidget, QToolBar
from PyQt5 import QtWidgets

import os

# note to recompile resources pyrcc5 -o resources.py resources.qrc 
# pyuic5 command on shell: pyuic4 input.ui -o output.py

from .modules.toolkitData.SiacDataSourceOptions import ProjectDataSourceOptions
from .modules.SiacDataStore import SiacDataStore
from .modules.SiacFoundation import LayerHelper, SelectionHelper, Utilities, FeatureCache, CachedLayerItem
from .modules.SiacEnumerations import *
from .modules.toolkit.TCAC import TreeConfigurationAssessmentAndClassification, TreeRichnessAndDiversityAssessment
from .modules.toolkit.TOPOMOD import TopologyModeller
from .modules.toolkit.SITA import SiteAssessment
from .modules.toolkit.COIN import IndicatorComputation
from .modules.toolkit.DATA import DataProcessor
from .modules.toolkitData.AttributeValueMapping import AttributeValueMapping, SerializableAttributeValueMappingDefinition, AttributeValueToEntityMapping, SiacLayerMappingType
from .modules.toolkitData.SiacDataStoreLayerSource import SiacDataStoreLayerSource
from .modules.toolkitData.SiacEntityRepresentation import SiacEntityRepresentation
from .modules.QtUi import QtUiMainDialogCallbacks
from .modules.QtUiWrapper import QtWrapper
from .modules.SiacRegressionModule import SiacRegressionModule, LocalRegressionParameters
from .modules.SiacImportExport import SiacExporter, SiacImporter

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ch_siac_dialog_ancillaydata import Ui_ancillaryLayerDialog
from .ch_siac_ui_main import Ui_MainWindow


from .modules.SiacEntityManagement import SiacEntityLayerManager





class siac:    

    # helper classes
    dataStore = None
    progress = None
    toolbuttonMenu = None
    progressMessageBar = None

    featureCache = FeatureCache()

    # define default values for SIAC, in form of options set
    params = {

        "OPTIONS" : {

            SiacToolkitOptionValue.DATAPROCESSOR_PARAMS_STREET_WIDTH : 20,
            SiacToolkitOptionValue.TCAC_PARAMS_USER_DEFINED_TREE_CROWN_DIAMETER : True,
            SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_VALUE : 10,
            SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_FIELDNAME : "",
            SiacToolkitOptionValue.TCAC_PARAMS_SPECIES_FIELDNAME : "",   
            SiacToolkitOptionValue.TCAC_PARAMS_ASSESS_TREE_ESS_SCALING : False,
            SiacToolkitOptionValue.TCAC_PARAMS_TREE_HEALTH_FIELDNAME : "",  
            SiacToolkitOptionValue.TCAC_PARAMS_FRUITTREE_SPECIES_LIST : [ 'MALUS', 'PRUNUS', 'PYRUS' ],            
            SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_SO2_REMOVALRATE : 1.32,
            SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_NO2_REMOVALRATE : 2.54,
            SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_PM10_REMOVALRATE : 2.73,
            SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_O3_REMOVALRATE : 3.06,
            SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_CO_REMOVALRATE : 0.58,
            SiacToolkitOptionValue.COIN_ESS_CARBON_STORAGERATE : 7.69,
            SiacToolkitOptionValue.COIN_ESS_CARBON_SEQUESTRATIONRATE : 0.28,
            SiacToolkitOptionValue.COIN_ESS_COOLING_PREDS_COVERTYPE : LocalRegressionConverType.USE_AREA.value,
            SiacToolkitOptionValue.COIN_ESS_COOLING_PREDS_INCLUDE_IMPV : LstRegressionPredictorSet.INCLUDE_IMPV_AS_SINGLE.value,
            SiacToolkitOptionValue.COIN_ESS_COOLING_INCLUDE_ANCILLARY_ENTITIES : True,
            SiacToolkitOptionValue.COIN_ESS_COOLING_INCLUDE_LOWESS : False,
            SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS : False,
            SiacToolkitOptionValue.SITA_PARAMS_SAMPLE_SIZE : 50,
            SiacToolkitOptionValue.SITA_PARAMS_PATCHDIAMETER : 90,
            SiacToolkitOptionValue.SITA_PARAMS_MIN_PATCHDISTANCE : 100,
            SiacToolkitOptionValue.CONNECTIVITY_PARAMS_ANCHOR_POINT : 0,
            SiacToolkitOptionValue.CONNECTIVITY_PARAMS_NEIGHBOUR_COUNT : 10,
            SiacToolkitOptionValue.CONNECTIVITY_PARAMS_THRESHOLD : 100, 
            SiacToolkitOptionValue.CONNECTIVITY_PARAMS_FRAGMENTATION_DISTANCES : "",
            SiacToolkitOptionValue.CONNECTIVITY_PARAMS_BUILDINGS_AS_BARRIERS : True,
            SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_BETWEENNESS : False,
            SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_CLOSENESS : False,
            SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_DEGREE_CENTRALITY : False,
            SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_COMPONENT_DIAMETER : False,
            SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_ECCENTRICITY : False,
            SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD : 0.5,
            SiacToolkitOptionValue.TYPOLOGY_FOREST_MINIMUM_AREA_THRESHOLD : 5000,
            SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD : 15,
            SiacToolkitOptionValue.TYPOLOGY_LINEARITY_THRESHOLD : 0.5
        }

    }


    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = iface.mapCanvas()
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'siac_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # initialize placeholder slots to store objects and outputs
        for toolType in SiacToolkitModule:
            self.params[toolType] = {}


        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&CLEARING HOUSE SIAC')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('siac', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        keybinding=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if keybinding is not None:
            self.iface.registerMainWindowAction(action, keybinding)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ch_siac/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'CLEARING HOUSE SIAC'),
            callback=self.run,
            parent=self.iface.mainWindow(),
            keybinding="Ctrl+F9")

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&CLEARING HOUSE SIAC'),
                action)
            self.iface.removeToolBarIcon(action)
    


    #######################################
    # Define map functions
    # Create map function functionalities
    ####################################### 

    mapTools = {
        MapCanvasTools.LOCALIZER_TOOL : None
    }

    def getPerimeterToolDiameter(self):        
        return float(self.dlg.perimeterValueSlider.value())

    def createMapTools(self):
        self.mapTools[MapCanvasTools.LOCALIZER_TOOL] = QgsMapToolEmitPoint(self.canvas)
        self.mapTools[MapCanvasTools.LOCALIZER_TOOL].canvasClicked.connect( self.mapFunctionCallbackLocalizerMapTool )
        self.dlg.btnLocalizerMapTool.clicked.connect(self.clickedBtnLocalizerMapTool)

    def clickedBtnLocalizerMapTool(self):

        # check if required data source exists
        hasTreeCoverLayer, treeCoverLayer = self.dataStore.getLayerOfType(DataLayer.TREE_COVER)
        hasStreetMorphologyLayer, streetMorphologyLayer = self.dataStore.getLayerOfType(DataLayer.MORPHOLOGY_STREETS)
        hasBuildingLayer, buildingLayer = self.dataStore.getLayerOfType(DataLayer.BUILDINGS)

        if not hasTreeCoverLayer or not hasStreetMorphologyLayer or not hasBuildingLayer:
            QtWrapper.showErrorMessage(self.dlg, "One or more required layer missing (Canopy Cover, Street Morphology, Buildings). Check data sources!")        
        else:
            # create tool scratch layer
            scrlayer = LayerHelper.createTemporaryLayer( ProjectDataSourceOptions.Crs, "MAPTOOL SCRATCH LAYER", "polygon")
            scrlayer = LayerHelper.createTemporaryLayerAttributes(scrlayer, [ 
                QgsField(SiacField.MAPTOOLS_PERIMETER_DIAMETER.value, QVariant.Double),  
                QgsField(SiacField.MORPHOLOGY_TREE_COVER_ENTITY_COUNT.value, QVariant.Int), 
                QgsField(SiacField.MORPHOLOGY_TREE_COVER_TOTAL.value, QVariant.Double), 
                QgsField(SiacField.MORPHOLOGY_TREE_COVER_RELATIVE.value, QVariant.Double),
                QgsField(SiacField.MORPHOLOGY_IMPERVIOUS_AREA_TOTAL.value, QVariant.Double),
                QgsField(SiacField.MORPHOLOGY_IMPERVIOUS_AREA_RELATIVE.value, QVariant.Double) ])
            
            self.params['TOOL_SCRATCH_LAYER'] = scrlayer
            
            scratchSymbol = QgsFillSymbol.createSimple({'color':'255,0,0,0','color_border':'#FF0000','width_border':'2'})        
            scratchMapLayer = QgsProject.instance().addMapLayer(self.params['TOOL_SCRATCH_LAYER'])
            scratchRenderer  = scratchMapLayer.renderer()
            scratchRenderer.setSymbol(scratchSymbol)
            scratchMapLayer.triggerRepaint()
            self.iface.layerTreeView().refreshLayerSymbology( scratchMapLayer.id() )

            # prepare cache, if not available
            if not self.featureCache.isCached(DataLayer.TREE_COVER):
                self.featureCache.cacheLayer(self.dataStore.getLayerOfType(DataLayer.TREE_COVER)[1], DataLayer.TREE_COVER)
            if not self.featureCache.isCached(DataLayer.MORPHOLOGY_STREETS):
                self.featureCache.cacheLayer(self.dataStore.getLayerOfType(DataLayer.MORPHOLOGY_STREETS)[1], DataLayer.MORPHOLOGY_STREETS)
            if not self.featureCache.isCached(DataLayer.BUILDINGS):
                self.featureCache.cacheLayer(self.dataStore.getLayerOfType(DataLayer.BUILDINGS)[1], DataLayer.BUILDINGS)

            # activate map tool
            self.canvas.setMapTool(self.mapTools[MapCanvasTools.LOCALIZER_TOOL])

    def mapFunctionCallbackLocalizerMapTool(self, e):        

        toolParams = {
            "LAYER" : self.params['TOOL_SCRATCH_LAYER'],
            "TOOL" : self.mapTools[MapCanvasTools.LOCALIZER_TOOL],
            "CANVAS" : self.canvas,
            "COORDINATE_X" : e[0],
            "COORDINATE_Y" : e[1],            
            "CACHE" : self.featureCache, 
            "LOGGER" : self.uiCallback.addToToolLog,
            "DIAMETER" : self.getPerimeterToolDiameter,
            DataLayer.TREE_COVER : self.dataStore.getLayerOfType(DataLayer.TREE_COVER)[1],  
            DataLayer.BUILDINGS : self.dataStore.getLayerOfType(DataLayer.BUILDINGS)[1],
            DataLayer.MORPHOLOGY_STREETS : self.dataStore.getLayerOfType(DataLayer.MORPHOLOGY_STREETS)[1]
        }
        SiteAssessment.assessMapLocation(toolParams)

    ###############################################
    # 
    # TCAC
    # 
    ################################################
    def taskAssessTreeFeaturesCompleted(self, success : bool, result : object):
        """Called upon execution of a TCAC task is completed.

        Args:
            success (bool): boolean indicator describing successfull execution of TCAC task
            result (object): parameters passed to TCAC task upon initialization, including results
        """

        if success:

            # update ui 
            self.uiCallback.disableInternalProgressReporter("TCAC Completed")
            self.uiCallback.addToToolLog(SiacToolkitModule.TCAC, result['results']['REPORT'])
        

            if result['TASK'] == TcacTask.MODEL_TREE_COVER:

                # update map view and simultaneously, add layers to data store                 
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.TREE_COVER])
                
            elif result['TASK'] == TcacTask.TREE_PATTERN_ASSESSMENT_AND_CLASSIFICATION:
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.TREE_COVER])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CLASSIFIED_TREES])
                #self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.TREE_COVER_MBR])
            
                # store richness and diversity assessment, if any
                if result['ASSESS_TREE_SPECIES_RICHNESS']:

                    self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT] = result['results']['DIVERSITY']                    
                    # make proportional abundance-rank graph
                    yvals = sorted(self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT].RelativeAbundance.values(), reverse=True)
                    
                    # interactive version?
                    #treeDf = self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT].TreeAbundanceAsDataFrame
                    #treeDf = treeDf.sort_values(by=['relative'], ascending=False)
                    #fig = px.scatter(treeDf, x=range(0, len(yvals)), y="relative", hover_data=['species'])
                    #fig.show()

                    fig = plt.figure()
                    ax = fig.add_subplot(1,1,1)
                    ax.plot(yvals)
                    ax.set_xlabel("Rank")
                    ax.set_ylabel("Relative abundance")
                    fig.show()

            elif result['TASK'] == TcacTask.MODEL_TRAITS_FROM_TALLO:
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.TREES])
                                    
            self.uiCallback.createMessageBar("TCAC Task completed", Qgis.MessageLevel.Success)

        else:
            QgsMessageLog.logMessage('TCAC module failed', "SIAC", Qgis.MessageLevel.Critical)
            self.uiCallback.createMessageBar('TCAC failed with error: {}'.format(result['exception']), Qgis.MessageLevel.Critical)

            # update ui 
            self.uiCallback.disableInternalProgressReporter("TCAC Failed")
        

    def initTcacTask(self, tcacTask : TcacTask):
        """Initializes TCAC task and starts a worker to execute the task.
        """
        
        # check if required data source exists
        treeLayer = self.dataStore.getItem(DataLayer.TREES)   
        treeCoverLayer = self.dataStore.getItem(DataLayer.TREE_COVER)

        # some sanity checks
        hasMissingData= False        
        if treeLayer is None:
            hasMissingData = True
        else:
            if (tcacTask == TcacTask.MODEL_TRAITS_FROM_TALLO or tcacTask == TcacTask.MODEL_TRAITS_FROM_UTDB):
                # this action requires species info as well as databases to be loaded.
                if not self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_SPECIES_FIELDNAME).split():
                    hasMissingData = True
                
                if tcacTask == TcacTask.MODEL_TRAITS_FROM_TALLO:
                    if not SiacToolkitDataType.TALLO_DB in self.params[SiacToolkitModule.TCAC].keys() or self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.TALLO_DB] is None:
                        hasMissingData = True
                elif tcacTask == TcacTask.MODEL_TRAITS_FROM_UTDB:
                    if not SiacToolkitDataType.URBAN_TREE_DB in self.params[SiacToolkitModule.TCAC].keys() or self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.URBAN_TREE_DB] is None:
                        hasMissingData = True


            elif tcacTask == TcacTask.TREE_PATTERN_ASSESSMENT_AND_CLASSIFICATION and treeCoverLayer is None:
                hasMissingData = True
            elif (self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_USER_DEFINED_TREE_CROWN_DIAMETER) == False and (self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_FIELDNAME) is None or self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_FIELDNAME) == "")):
                hasMissingData = True
            elif (self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_ASSESS_TREE_ESS_SCALING) == True and (self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_HEALTH_FIELDNAME) is None or self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_HEALTH_FIELDNAME) == "")):
                hasMissingData = True



        if hasMissingData:
            QtWrapper.showErrorMessage(self.dlg, "Required data is missing")  
            return          
        
        else:

            # create worker parameters to pass to worker
            workerParams = {
                "CRS" : ProjectDataSourceOptions.Crs,
                "TASK" : tcacTask,
                "CACHE" : self.featureCache,
                DataLayer.TREES : treeLayer,
                SiacToolkitOptionValue.TCAC_PARAMS_USER_DEFINED_TREE_CROWN_DIAMETER : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_USER_DEFINED_TREE_CROWN_DIAMETER),
                SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_VALUE : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_VALUE),
                SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_FIELDNAME : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_CROWN_DIAMETER_FIELDNAME),     
                SiacToolkitOptionValue.TCAC_PARAMS_ASSESS_TREE_ESS_SCALING : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_ASSESS_TREE_ESS_SCALING),
                SiacToolkitOptionValue.TCAC_PARAMS_TREE_HEALTH_FIELDNAME : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_TREE_HEALTH_FIELDNAME),           
                SiacToolkitOptionValue.TCAC_PARAMS_SPECIES_FIELDNAME : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_SPECIES_FIELDNAME),
                SiacToolkitOptionValue.TCAC_PARAMS_FRUITTREE_SPECIES_LIST : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_FRUITTREE_SPECIES_LIST),
                SiacToolkitOptionValue.TYPOLOGY_LINEARITY_THRESHOLD : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_LINEARITY_THRESHOLD),
                SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD)
            }

            

            # add parameters depending on task
            if tcacTask == TcacTask.MODEL_TREE_COVER:
                pass

            elif tcacTask == TcacTask.TREE_PATTERN_ASSESSMENT_AND_CLASSIFICATION:                
                workerParams[DataLayer.TREE_COVER] = treeCoverLayer

            elif tcacTask == TcacTask.MODEL_TRAITS_FROM_TALLO:
                workerParams['DB'] = self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.TALLO_DB]
                workerParams['DB_TYPE'] = SiacToolkitDataType.TALLO_DB
            elif tcacTask == TcacTask.MODEL_TRAITS_FROM_UTDB:
                workerParams['DB'] = self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.URBAN_TREE_DB]
                workerParams['DB_TYPE'] = SiacToolkitDataType.URBAN_TREE_DB


            # user feedback and progress
            self.uiCallback.createMessageBarWithProgress("Initializing TCAC tool")
            self.uiCallback.enableInternalProgressReporter("Running TCAC")
            
            self.tcacWorker = TreeConfigurationAssessmentAndClassification(workerParams)
            self.tcacWorker.jobFinished.connect(self.taskAssessTreeFeaturesCompleted)   
            self.tcacWorker.siacToolMaximumProgressValue.connect(self.uiCallback.setMaximumProgressValue)
            self.tcacWorker.siacToolProgressValue.connect(self.uiCallback.setProgressValue)
            self.tcacWorker.siacToolProgressMessage.connect(self.uiCallback.setProgressMessage)

            # run task/worker            
            QgsApplication.taskManager().addTask(self.tcacWorker)



    ###############################################
    # 
    # TOPOMOD
    # 
    ################################################
    def taskTopologyModellingCompleted(self, success : bool, result : object):
        """Called upon execution of a TOPOMOD task is completed.

        Args:
            success (bool): boolean indicator describing successfull execution of TCAC task
            result (object): parameters passed to TCAC task upon initialization, including results
        """

        if success:

            self.uiCallback.createMessageBar("TOPOMOD Task Completed", messageLevel=Qgis.MessageLevel.Success)            
            
            # update ui 
            self.uiCallback.disableInternalProgressReporter("TOPOMOD Completed")
            self.uiCallback.addToToolLog(SiacToolkitModule.TOPOMOD, result['results']['REPORT'])
           
            # add result layers to map depending on task performed
            if result['TASK'] == TopomodTask.COMPUTE_TOPOLOGY:
                
                # add relevant layers to map
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.TREE_COVER])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.MORPHOLOGY_STREETS])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.BUILDINGS])


                # add optional layers
                if result[DataLayer.CLASSIFIED_TREES] is not None:
                    self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CLASSIFIED_TREES])                    

                # add shortest line features to map
                for ds in result['results'][SiacToolkitDataType.NEAR_LAYER]:
                    self.dataStore.addDataStoreLayerSource(ds)

                

            # this adds to the model the computed ancillary data-based entity layers
            if result[DataLayer.ANCILLARY_DATA] is not None:
                for entity in result[DataLayer.ANCILLARY_DATA].getEntityRepresentations():
                    self.dataStore.addDataStoreLayerSource(entity.Layer)

            if result['TASK'] == TopomodTask.COMPUTE_NEAREST_NEIGHBOUR_NETWORK:
                # add relevant layers to map
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CONNECTIVITY_NEAREST_NEIGHBOURS])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CONNECTIVITY_BASE_LAYER])


            if result['TASK'] == TopomodTask.COMPUTE_CONNECTIVITY:
                # add relevant layers to map
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CONNECTIVITY_BASE_LAYER])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CONNECTIVITY_EDGES])
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.CONNECTIVITY_NODES])
                
                # store graph for later reference
                self.params[SiacToolkitModule.TOPOMOD][SiacToolkitDataType.GRAPH] = result['results'][SiacToolkitDataType.GRAPH][str(result['CONNECTIVITY_THRESHOLD'])]      

            if result['TASK'] == TopomodTask.ASSESS_FRAGMENTATION:
                deltas = result['results']['C_DELTA']
                
                # make plots
                distVals = [ x['dist'] for x in deltas ]
                componentVals = [ x['components'] for x in deltas ]
                meanSizeVals = [ x['mean_size'] for x in deltas ]

                fig, (ax1, ax2) = plt.subplots(ncols=2, nrows=1)
                ax1.plot(distVals, componentVals)                                
                ax2.plot(distVals, meanSizeVals)                                
                                        
                ax1.set_xlabel("Connectivity Threshold")
                ax1.set_ylabel("Number of Components")
                ax2.set_xlabel("Connectivity Threshold")
                ax2.set_ylabel("Mean size of the components")

                fig.show()
           
        else:
            QgsMessageLog.logMessage('TOPOMOD module failed', "SIAC", Qgis.MessageLevel.Critical)
            self.uiCallback.createMessageBar('TOPOMOD failed with error: {}'.format(result['exception']), Qgis.MessageLevel.Critical)
            
            # update ui 
            self.uiCallback.disableInternalProgressReporter("TOPOMOD Failed")


    def initTopomodTaskComputeSpatialRelationships(self, workerParams):
        """Initializes parameters for a TOPOMOD task to determine spatial relationships, then calls the method that executes the task. 

        Args:
            workerParams (dict): parameters for task to be executed.
        """
        
        # required data sources
        streetMorphologyLayer = self.dataStore.getItem(DataLayer.MORPHOLOGY_STREETS)
        canopyLayer = self.dataStore.getItem(DataLayer.TREE_COVER)                        
        buildingsLayer = self.dataStore.getItem(DataLayer.BUILDINGS)                                  
        streetLayer = self.dataStore.getItem(DataLayer.STREETS)

        if streetMorphologyLayer is None or canopyLayer is None or buildingsLayer is None or streetLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Required TOPOMOD data layers are missing. (Re-)Run TCAC tool or specify layers manually")
            return

        # optional layers
        classifiedTreeLayer = self.dataStore.getItem(DataLayer.CLASSIFIED_TREES)                                                

        workerParams.update({
            DataLayer.BUILDINGS : buildingsLayer,
            DataLayer.CLASSIFIED_TREES : classifiedTreeLayer,
            DataLayer.TREE_COVER : canopyLayer,
            DataLayer.MORPHOLOGY_STREETS : streetMorphologyLayer,
            DataLayer.STREETS : streetLayer,
            SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD)
        })
        self.runTopomodTask(workerParams)

    
    def initTopomodTaskComputeShortestLines(self, workerParams):
        """Initializes parameters for a TOPOMOD task to compute nearest neighbour network for connectivity analysis, then calls the method that executes the task.

        Args:
            workerParams (dict): parameters for task to be executed.
        """
        
        # new shortest lines invalidate graph: disable export button
        self.params[SiacToolkitModule.TOPOMOD][SiacToolkitDataType.GRAPH] = None

        # required data sources
        canopyLayer = self.dataStore.getItem(DataLayer.TREE_COVER)            
    
        if canopyLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Required TOPOMOD data layers are missing. (Re-)Run TCAC tool or specify layers manually")
            return
        
        workerParams.update({
            DataLayer.TREE_COVER : canopyLayer,
            "NN_COUNT" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_NEIGHBOUR_COUNT),
            "ANCHOR" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_ANCHOR_POINT)
        })
        self.runTopomodTask(workerParams)

    def initTopomodTaskFragmentation(self, workerParams):
        """Initializes the parameters for a TOPOMOD task to determine fragmentation, then calls the method that executes the task.

        Args:
            workerParams (dict): parameters for task to be executed.
        """

        if self.dlg.textComponentDelta.text() == '':
            QtWrapper.showErrorMessage(self.dlg, "Please specify connectivity thresholds, separated by semicolon.")
            return

        userRanges = []
        tmp = self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_FRAGMENTATION_DISTANCES).split(';')
        for r in tmp:
            userRanges.append(float(r))

        self.params['CONNECTIVITY_RANGES'] = userRanges

        # required data sources
        buildingsLayer = self.dataStore.getItem(DataLayer.BUILDINGS)                                  
        baseLayer = self.dataStore.getItem(DataLayer.CONNECTIVITY_BASE_LAYER)                        
        shortestLinesLayer = self.dataStore.getItem(DataLayer.CONNECTIVITY_NEAREST_NEIGHBOURS)
    
        if buildingsLayer is None or baseLayer is None or shortestLinesLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Required TOPOMOD data layers are missing. (Re-)Run TCAC tool or SHORTEST LINES tool or specify layers manually")
            return
        
        workerParams.update({
            DataLayer.BUILDINGS : buildingsLayer,
            DataLayer.CONNECTIVITY_BASE_LAYER : baseLayer,
            DataLayer.CONNECTIVITY_NEAREST_NEIGHBOURS : shortestLinesLayer,
            "RANGES" : userRanges,
            "BUILDINGS_AS_BARRIERS" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_BUILDINGS_AS_BARRIERS)
        })

        self.runTopomodTask(workerParams)

    def initTopomodTaskComputeConnectivity(self, workerParams):
        """Initializes the parameters for a TOPOMOD task to assess connectivity, then calls the method that executes the task.

        Args:
            workerParams (dict): parameters for task to be executed.
        """
        
        
        
        # required data sources
        buildingsLayer = self.dataStore.getItem(DataLayer.BUILDINGS)                                  
        baseLayer = self.dataStore.getItem(DataLayer.CONNECTIVITY_BASE_LAYER)                        
        shortestLinesLayer = self.dataStore.getItem(DataLayer.CONNECTIVITY_NEAREST_NEIGHBOURS)
    
        if buildingsLayer is None or baseLayer is None or shortestLinesLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Required TOPOMOD data layers are missing. (Re-)Run TCAC tool or SHORTEST LINES tool or specify layers manually")
            return
        
        workerParams.update({
            DataLayer.BUILDINGS : buildingsLayer,
            DataLayer.CONNECTIVITY_BASE_LAYER : baseLayer,
            DataLayer.CONNECTIVITY_NEAREST_NEIGHBOURS : shortestLinesLayer,
            "CONNECTIVITY_THRESHOLD" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_THRESHOLD),            
            "BUILDINGS_AS_BARRIERS" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_PARAMS_BUILDINGS_AS_BARRIERS),
            "ADVANCED_INDICATORS" : {
                'BETWEENNESS' : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_BETWEENNESS),
                'CLOSENESS' : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_CLOSENESS),
                'DEGREE_CENTRALITY' : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_DEGREE_CENTRALITY),
                'DIAMETER' : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_COMPONENT_DIAMETER),
                'ECCENTRICITY' : self.uiCallback.getOptionValue(SiacToolkitOptionValue.CONNECTIVITY_INDICATORS_ECCENTRICITY)
            }
        })
        self.runTopomodTask(workerParams)
       

    
    def runTopomodTask(self, workerParams):
        """Executes a TOPOMOD task.

        Args:
            workerParams (dict): Parameters for the TOPOMOD task to be executed
        """

        # initialize worker and start TOPOMOD task        
        self.uiCallback.createMessageBarWithProgress("Initializing TOPOMOD tool")
        self.uiCallback.enableInternalProgressReporter("Running TOPOMOD")
       
        # other ancillary layers to be included
        ancillaryData = self.dataStore.getEntityLayerManager(TopologyModeller.getModuleSupportedEntityTypes(workerParams['TASK']))
        workerParams[DataLayer.ANCILLARY_DATA] = ancillaryData                                                                         

        self.topomodWorker = TopologyModeller(workerParams)
        self.topomodWorker.jobFinished.connect(self.taskTopologyModellingCompleted)   
        self.topomodWorker.siacToolMaximumProgressValue.connect(self.uiCallback.setMaximumProgressValue)
        self.topomodWorker.siacToolProgressValue.connect(self.uiCallback.setProgressValue)
        self.topomodWorker.siacToolProgressMessage.connect(self.uiCallback.setProgressMessage)
        
        # run task/worker            
        QgsApplication.taskManager().addTask(self.topomodWorker)
    




    def initTopomodTask(self, requestedTask : TopomodTask):
        """Calls the corresponding method to setup a specific TOPOMOD task

        Args:
            requestedTask (TopomodTask): TOPOMOD task to be executed
        """

        workerParams = {
            'TASK' : requestedTask,
            "CACHE" : self.featureCache,                                   
            "CRS" : ProjectDataSourceOptions.Crs
        }

        if requestedTask == TopomodTask.COMPUTE_TOPOLOGY:
            self.initTopomodTaskComputeSpatialRelationships(workerParams)
        if requestedTask == TopomodTask.COMPUTE_NEAREST_NEIGHBOUR_NETWORK:
            self.initTopomodTaskComputeShortestLines(workerParams)
        if requestedTask == TopomodTask.COMPUTE_CONNECTIVITY:
            self.initTopomodTaskComputeConnectivity(workerParams)
        if requestedTask == TopomodTask.ASSESS_FRAGMENTATION:
            self.initTopomodTaskFragmentation(workerParams)



    ###############################################
    # 
    # SITA
    # 
    ################################################
    def taskSiteAssessmentCompleted(self, success : bool, result : object):
        """Called upon execution of a SITA task is completed.

        Args:
            success (bool): boolean indicator describing successfull execution of TCAC task
            result (object): parameters passed to SITA task upon initialization, including results
        """

        if success:
            
            self.uiCallback.createMessageBar("SITA Task Completed", messageLevel=Qgis.MessageLevel.Success)            
                        
            # update ui 
            self.uiCallback.disableInternalProgressReporter("SITA Completed")
            self.uiCallback.addToToolLog(SiacToolkitModule.SITA, result['results']['REPORT'])

            if result['TASK'] == SitaTask.ITERATE_PLOTS:                
                self.dataStore.addDataStoreLayerSource(result['results']['BASE_LAYER'])
               
            if result['TASK'] == SitaTask.ITERATE_SAMPLED_LOCATIONS:
                # add result
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.SITA_SAMPLED_LOCATIONS])

            # this adds to the model the computed ancillary data-based entity layers
            if result['ENTITY_LAYERS'] is not None:
                for entity in result['ENTITY_LAYERS'].getEntityRepresentations():
                    self.dataStore.addDataStoreLayerSource(entity.Layer)
           
        else:
            QgsMessageLog.logMessage('SITA module failed', "SIAC", Qgis.MessageLevel.Critical)
            self.uiCallback.createMessageBar('SITA failed with error: {}'.format(result['exception']), Qgis.MessageLevel.Critical)
            
            # update ui 
            self.uiCallback.disableInternalProgressReporter("SITA Failed")


   

    def initSitaTask(self, sitaTask : SitaTask):
        """Initializes a SITA task, creates a worker and executes the task

        Args:
            sitaTask (SitaTask): SITA task to be executed.
        """

        # some initial requirement checks
        hasCanopyLayer, canopyLayer = self.dataStore.getLayerOfType(DataLayer.TREE_COVER)     
        hasStreetMorphologyLayer, streetMorphologyLayer = self.dataStore.getLayerOfType(DataLayer.MORPHOLOGY_STREETS)                 
        hasBuildingLayer, buildingLayer = self.dataStore.getLayerOfType(DataLayer.BUILDINGS)
        
        # Sanity check for absolutely required data
        if not hasCanopyLayer or not hasStreetMorphologyLayer or not hasBuildingLayer:
            # issue user error
            QtWrapper.showErrorMessage(self.dlg, "Required data layers are missing. (Re-)Run TCAC or TOPOMOD tool or specify layers manually")
            return     

        # deprecated: relevant plot layer (or polygon layer therefore) now selected by user
        # test if we have certain layers that we need                        
        # hasTessellationLayer, tessellationLayer = self.dataStore.getLayerOfType(DataLayer.MORPHOLOGY_ENCLOSED_TESSELLATION)   
        
        # basically, tessellation layer should be any type of polygon layer: try replacing the layer with selected layer from model!
        # also, we only need that layer if we do not draw a random sample
        baseLayer = None        

        if sitaTask == SitaTask.ITERATE_PLOTS:
            # here, we need to take care of user selection
            baseLayer = self.getUserSelectedLayer()           
            if baseLayer is None:
                QtWrapper.showErrorMessage(self.dlg, "Click-select a layer to use as base layer in SITA from the model and re-run SITA tool.")
                return
                

        elif sitaTask == SitaTask.ITERATE_SAMPLED_LOCATIONS:
            # here, we don't really need a base layer
            pass
  
        # optional layers to be passed to the tool: layer itself would be None if not included in the model           
        hasClassifiedTreeLayer, classifiedTreeLayer = self.dataStore.getLayerOfType(DataLayer.CLASSIFIED_TREES)                                                

        # other ancillary layers to be included
        ancillaryData = self.dataStore.getEntityLayerManager(SiteAssessment.getModuleSupportedSiacEntityTypes())
            
        # create worker parameters to pass to worker
        workerParams = {
            "BASE_LAYER" : baseLayer,     
            DataLayer.CLASSIFIED_TREES : classifiedTreeLayer,
            DataLayer.TREE_COVER : canopyLayer,                
            DataLayer.BUILDINGS : buildingLayer,
            DataLayer.MORPHOLOGY_STREETS : streetMorphologyLayer,
            DataLayer.ANCILLARY_DATA : ancillaryData,                
            "TASK" : sitaTask,
            "CACHE" : self.featureCache,                   
            "CRS" : ProjectDataSourceOptions.Crs,
            "SPECIES_ATTRIBUTE" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_SPECIES_FIELDNAME),
            "FRUIT_TREE_SPECIES" : self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_FRUITTREE_SPECIES_LIST)                
        }

        if sitaTask == SitaTask.ITERATE_SAMPLED_LOCATIONS:
            workerParams['SAMPLE_SIZE'] = self.uiCallback.getOptionValue(SiacToolkitOptionValue.SITA_PARAMS_SAMPLE_SIZE)
            workerParams['SAMPLE_DIST'] = self.uiCallback.getOptionValue(SiacToolkitOptionValue.SITA_PARAMS_MIN_PATCHDISTANCE)
            workerParams['SAMPLE_DIAMETER'] = self.uiCallback.getOptionValue(SiacToolkitOptionValue.SITA_PARAMS_PATCHDIAMETER)

        # initialize worker and start TOPOMOD task        
        self.uiCallback.createMessageBarWithProgress("Initializing SITA tool")
        self.uiCallback.enableInternalProgressReporter("Running SITA")

        self.sitaWorker = SiteAssessment(workerParams)
        self.sitaWorker.jobFinished.connect(self.taskSiteAssessmentCompleted)   
        self.sitaWorker.siacToolMaximumProgressValue.connect(self.uiCallback.setMaximumProgressValue)
        self.sitaWorker.siacToolProgressValue.connect(self.uiCallback.setProgressValue)
        self.sitaWorker.siacToolProgressMessage.connect(self.uiCallback.setProgressMessage)
        
        # run task/worker            
        QgsApplication.taskManager().addTask(self.sitaWorker)

    ###############################################
    # 
    # DATA PROCESSOR
    # 
    ################################################
    def taskDataProcessorCompleted(self, success : bool, result : object):
        """Called upon execution of a DATA PROCESSOR task is completed.

        Args:
            success (bool): boolean indicator describing successfull execution of TCAC task
            result (object): parameters passed to DATA PROCESSOR task upon initialization, including results
        """

        if success:
            self.uiCallback.createMessageBar("DATA PROCESSOR Task Completed", messageLevel=Qgis.MessageLevel.Success)            

            # update ui 
            self.uiCallback.disableInternalProgressReporter("DATA PROCESSOR Completed")
                       
            # add result as per task
            if result['TASK'] is DataProcessorTask.COMPUTE_STREET_MORPHOLOGY:
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.MORPHOLOGY_STREETS])

            if result['TASK'] is DataProcessorTask.COMPUTE_CLOSED_TESSELLATION: 
                self.dataStore.addDataStoreLayerSource(result['results'][DataLayer.MORPHOLOGY_PLOTS])     
  
           
        else:
            QgsMessageLog.logMessage('DATA PROCESSOR module failed', "SIAC", Qgis.MessageLevel.Critical)
            self.uiCallback.createMessageBar('DATA PROCESSOR failed with error: {}'.format(result['exception']), Qgis.MessageLevel.Critical)
            
            # update ui 
            self.uiCallback.disableInternalProgressReporter("DATA PROCESSOR Failed")


    def initDataProcessorTask(self, taskType : DataProcessorTask):
        """Initializes a DATA PROCESSOR task, creates a worker and executes the task

        Args:
            taskType (DataProcessorTask): DATA PROCESSOR task to be executed
        """

        # test if we have certain layers that we need                        
        streetLayer = self.dataStore.getItem(DataLayer.STREETS)                                                
        buildingsLayer = self.dataStore.getItem(DataLayer.BUILDINGS)                    

        if streetLayer is None or buildingsLayer is None:
            # issue user error
            QtWrapper.showErrorMessage(self.dlg, "Required DATA PROCESSOR input layers are missing. Check missing layers.")
            return
        
        else:
            
            # create worker parameters to pass to worker
            workerParams = {
                DataLayer.STREETS : streetLayer,
                DataLayer.BUILDINGS : buildingsLayer,                
                "TASK"  : taskType,     
                "CACHE" : self.featureCache,                   
                "CRS" : ProjectDataSourceOptions.Crs
            }

            # depending on task type, see if other worker parameters need to be provided
            if taskType is DataProcessorTask.COMPUTE_STREET_MORPHOLOGY:
                # update maximum street width (from centerline)                
                workerParams["MAXIMUM_STREET_WIDTH"] = self.uiCallback.getOptionValue(SiacToolkitOptionValue.DATAPROCESSOR_PARAMS_STREET_WIDTH)

            # initialize worker and start TOPOMOD task        
            self.uiCallback.createMessageBarWithProgress("Initializing DATA PROCESSOR tool")
            self.uiCallback.enableInternalProgressReporter("Running DATA PROCESSOR")

            self.dwWorker = DataProcessor(workerParams)
            self.dwWorker.jobFinished.connect(self.taskDataProcessorCompleted)   
            self.dwWorker.siacToolMaximumProgressValue.connect(self.uiCallback.setMaximumProgressValue)
            self.dwWorker.siacToolProgressValue.connect(self.uiCallback.setProgressValue)
            self.dwWorker.siacToolProgressMessage.connect(self.uiCallback.setProgressMessage)
            
            # run task/worker            
            QgsApplication.taskManager().addTask(self.dwWorker)


    ###############################################
    # 
    # COIN
    # 
    ################################################
    def taskIndicatorComputationCompleted(self, success : bool, result : object):
        """Called upon execution of a COIN task is completed.

        Args:
            success (bool): boolean indicator describing successfull execution of TCAC task
            result (object): parameters passed to COIN task upon initialization, including results
        """

        if success:
            self.uiCallback.createMessageBar("COIN Task Completed", messageLevel=Qgis.MessageLevel.Success)            

            # update ui 
            self.uiCallback.disableInternalProgressReporter("COIN Completed")
            self.uiCallback.addToToolLog(SiacToolkitModule.COIN, result['results']['REPORT'])
            
            # add data sources from result to data store
            for newLayer in result['results']['LAYERS'].values():
                self.dataStore.addDataStoreLayerSource(newLayer)      

            if SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT in result['results'].keys():
                currentResult = result['results'][SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT]
                
                # make proportional abundance-rank graph
                yvals = sorted(currentResult.RelativeAbundance.values(), reverse=True)
                fig = plt.figure()
                ax = fig.add_subplot(1,1,1)
                ax.plot(yvals)
                ax.set_xlabel("Rank")
                ax.set_ylabel("Relative abundance")
                fig.show()

            if SiacToolkitDataType.LOCAL_COOLING_POTENTIAL_DATA in result['results'].keys():

                currentRegression : LocalRegressionParameters = result['results'][SiacToolkitDataType.LOCAL_COOLING_POTENTIAL_DATA]                
                self.params[SiacToolkitModule.COIN][SiacToolkitDataType.LOCAL_COOLING_POTENTIAL_DATA] = currentRegression
                
                plots = SiacRegressionModule.makeRegressionPlots( currentRegression, includeLowess = currentRegression.IncludeLowess )        
                for fig in plots:
                    fig.show()

        else:
            QgsMessageLog.logMessage('COIN module failed', "SIAC", Qgis.MessageLevel.Critical)
            self.uiCallback.createMessageBar('COIN failed with error: {}'.format(result['exception']), Qgis.MessageLevel.Critical)

            # update ui 
            self.uiCallback.disableInternalProgressReporter("COIN Failed")

    def initCoinTask(self, workerParams):
        """Initializes a COIN task, creates a worker and executes the task

        Args:
            workerParams (_type_): Task parameters for the task to be executed.
        """

        # append further opjects to workerParams
        workerParams['GET_DATA_HANDLER'] = self.dataStore.getItem

        # update ui 
        self.uiCallback.createMessageBarWithProgress("Initializing COIN tool") 
        self.uiCallback.enableInternalProgressReporter("Running COIN")
        
        self.coinWorker = IndicatorComputation(workerParams)
        self.coinWorker.jobFinished.connect(self.taskIndicatorComputationCompleted)
        self.coinWorker.siacToolMaximumProgressValue.connect(self.uiCallback.setMaximumProgressValue)
        self.coinWorker.siacToolProgressValue.connect(self.uiCallback.setProgressValue)
        self.coinWorker.siacToolProgressMessage.connect(self.uiCallback.setProgressMessage)
        

        # run task/worker            
        QgsApplication.taskManager().addTask(self.coinWorker)


    def getUserSelectedLayer(self):        
        activeLayer = self.dataStore.getActiveLayer()
        return activeLayer
        

    def exportGraph(self):
        if SiacToolkitDataType.GRAPH in self.params[SiacToolkitModule.TOPOMOD].keys():
            SiacExporter.toGraphMl(self.dlg, self.params[SiacToolkitModule.TOPOMOD][SiacToolkitDataType.GRAPH])
        else:
            QtWrapper.showErrorMessage(self.dlg, "No connectivity graph stored in model. Re-Run TOPOMOD tools.")

    def exportRegressionParamsObject(self):
        SiacExporter.toPickle(self.dlg, "SIAC Regression Parameters (*.siacreg)", self.params[SiacToolkitModule.COIN][SiacToolkitDataType.LOCAL_COOLING_POTENTIAL_DATA])
    
    def importRegressionParamsObject(self):
        regrData = SiacImporter.fromPickle(self.dlg, "SIAC Regression Parameters (*.siacreg)")
        if regrData is not None:
            self.params[SiacToolkitModule.COIN][SiacToolkitDataType.LOCAL_COOLING_POTENTIAL_DATA] = regrData
            QtWrapper.showErrorMessage(self.dlg, "Data loaded - Ready to run Local cooling potential")
        else:
            QtWrapper.showErrorMessage(self.dlg, "Error importing data.")


    def exportRichnessAndDiversityResult(self):
        fileName, filterString = QtWidgets.QFileDialog.getSaveFileName(self.dlg, "Save File", "", "Excel Files (*.xlsx)")
        if fileName:

            cdata : TreeRichnessAndDiversityAssessment = self.params[SiacToolkitModule.TCAC][SiacToolkitDataType.RICHNESS_AND_DIVERSITY_ASSESSMENT]

            # writing richness and diversity data to excel file
            newWorkbook = xlsx.Workbook(fileName)
            
            # write summaries
            worksheet0 = newWorkbook.add_worksheet()
            # write headers
            worksheet0.write(0,0, "Total tree abundance (Tree Count)")
            worksheet0.write(0,1, cdata.TreeAbundance)
            worksheet0.write(1,0, "Richness S")
            worksheet0.write(1,1, cdata.Richness)
            worksheet0.write(2,0, "Total number of fruit trees identified")
            worksheet0.write(2,1, cdata.TotalNumberOfFruitTrees)
            worksheet0.write(3,0, "Menhinick Index")
            worksheet0.write(3,1, cdata.MenhinickIndex)
            worksheet0.write(4,0, "Margalef Index")
            worksheet0.write(4,1, cdata.MargalefIndex)
            worksheet0.write(5,0, "Simpson Index D")
            worksheet0.write(5,1, cdata.SimpsonIndex)
            worksheet0.write(6,0, "Simpson Index (1-D)")
            worksheet0.write(6,1, cdata.ComplementedSimpsonIndex)
            worksheet0.write(7,0, "Brillouin Index H")
            worksheet0.write(7,1, cdata.BrillouinIndex)            
            worksheet0.write(8,0, "ShannonWiener Diversity Index H'")
            worksheet0.write(8,1, cdata.ShannonWienerDiversityIndex)
            worksheet0.write(9,0, "Pielou Evenness Index J'")
            worksheet0.write(9,1, cdata.PielouEvennessIndex)

            # write relative abundance data
            worksheet1 = newWorkbook.add_worksheet()
            row = 0            
            # write headers
            worksheet1.write(row, 0, "Genus/Species")
            worksheet1.write(row, 1, "Tree Count")
            worksheet1.write(row, 2, "Relative Abundance")

            for species, count in sorted(cdata.SpeciesData.items()):
                row += 1
                worksheet1.write(row, 0, species)
                worksheet1.write(row, 1, count)
                worksheet1.write(row, 2, 100*(count/cdata.TreeAbundance))

            newWorkbook.close()
            self.uiCallback.createMessageBar("Data written to Excel", Qgis.MessageLevel.Success)
    
    
    def loadModel(self):
        data = SiacImporter.fromPickle(self.dlg, "SIAC MODEL (*.siacmod)")
        if data is not None:
            for toolkit in SiacToolkitModule:
                self.params[toolkit] = data[toolkit]    

            layers = data['LAYERS']
            for l in layers:

                cLayerUid = None
                cLayer, cLayerId = self.getMatchingLayerByLayerName( l['LAYER_NAME'] )
                if cLayer is not None:
                    cLayerTypeAsString = l['LAYER_TYPE']                   
                    aLayer = SiacDataStoreLayerSource.makeNewDataStoreLayerSourceItem(cLayer, cLayerTypeAsString, cLayer.name(), cLayerId )                                                         

                    if DataLayer(cLayerTypeAsString) == DataLayer.ANCILLARY_DATA: 
                        lMapping : SerializableAttributeValueMappingDefinition = l['LAYER_MAPPING']
                        if lMapping is not None:               
                            aLayer.LayerMapping.FieldName = lMapping.fieldName
                            aLayer.LayerMapping.LayerEntityType = lMapping.layerEntityType
                            aLayer.LayerMapping.MappingType = lMapping.mappingType
                            aLayer.LayerMapping.setMappings(lMapping.attribsToEntitiesMapping) 
                    
                    self.dataStore.addDataStoreLayerSource(aLayer)

                    if DataLayer(cLayerTypeAsString) == DataLayer.TREES:
                        self.uiCallback.enableTreeLayerFieldPickers(aLayer.LayerSource)                     

            self.uiCallback.updatePickerDataLayerTypes()
            self.uiCallback.applyOptionSet(data['OPTIONS'])

    def saveModel(self):

        # prepare dict to be pickled
        data = {}
        # include options
        # TODO: Implement a sync between UI state and options state
        data['OPTIONS'] = self.uiCallback.collectOptionSet()

        # include toolit results stored internally
        for toolkit in SiacToolkitModule:
            data[toolkit] = self.params[toolkit]

        # include layers as list of tuples: DataLayer type, layer name, layer attribute mapping
        data['LAYERS'] = self.dataStore.serializeLayerDefinitions()

        SiacExporter.toPickle(self.dlg, "SIAC MODEL (*.siacmod)", data) 

    def importExternalDatabase(self, dbType : SiacToolkitDataType):
        data = SiacImporter.fromCsv(self.dlg)   
        if data is not None:            
            self.params[SiacToolkitModule.TCAC][dbType] = data 

            if dbType == SiacToolkitDataType.TALLO_DB:
                self.dlg.statusTallo.setStyleSheet('QFrame{background-color : #00FF00;}')
            elif dbType == SiacToolkitDataType.URBAN_TREE_DB:
                self.dlg.statusUTDB.setStyleSheet('QFrame{background-color: #00FF00;}')

            self.uiCallback.disableInternalProgressReporter("Database Import Complete")
        
        else:
            self.uiCallback.disableInternalProgressReporter("Database Import Failed")


    

    def getMatchingLayerByDataType(self, dataSource : DataLayer):
        
        resLayer = None
        resLayerId = None
        resLayerUid = None

        # attempt to match datasources to datatypes by name, to facilitate DS selection
        layers = QgsProject.instance().mapLayers()
        for layer_id, layer in layers.items():            
            if dataSource.value.lower() == layer.name().lower():                
                resLayer = layer
                resLayerId = layer_id
                if dataSource == DataLayer.ANCILLARY_DATA:
                    resLayerUid = uuid.uuid4().hex
                break
                
        return resLayer, resLayerId, resLayerUid
    
    def getMatchingLayerByLayerName(self, targetLayerName : str):
        
        resLayer = None
        resLayerId = None

        # attempt to match datasources to datatypes by name
        layers = QgsProject.instance().mapLayers()
        for layer_id, layer in layers.items():            
            if targetLayerName.lower() == layer.name().lower():                
                resLayer = layer
                resLayerId = layer_id                
                break                
        
        return resLayer, resLayerId
            
    
    def resolveDataSources(self, interactive : bool = True) -> None:
        """
         Attempt to match data source types to QGIS map layers. 
         
         Args:
         	 interactive: If True prompt user to select tree genus/tree species field once matching is resolved and tree layer has been matched (Currently inop).
         
         Returns: 
         	 None
        """


        # remove rows prior resolving layers
        self.dataStore.clear()        
        
        # iterate over datasource types and layers
        for dataSource in DataLayer:
            
            currentLayer, currentLayerId, layerUid = self.getMatchingLayerByDataType(dataSource)
            if currentLayer is not None:

                self.uiCallback.enableInternalProgressReporter("Importing feature layer into SIAC model")

                # with the new flow, as this is by definition a new data source,
                # create a new datatorelayersource item and let the store handle adding to map etc.
                currentType = dataSource.value
                currentName = currentLayer.name()
                newLayerSource = SiacDataStoreLayerSource.makeNewDataStoreLayerSourceItem( currentLayer, currentType, currentName, currentLayerId )                
                self.dataStore.addDataStoreLayerSource(newLayerSource)
                self.uiCallback.disableInternalProgressReporter()

        self.uiCallback.updatePickerDataLayerTypes()
        self.uiCallback.updateStatusBarProgressMessage("Attempted to resolve data sources")
        

        # if tree layer has been added, prompt user offer to select field
        hasTreeLayer, treeLayer = self.dataStore.getLayerOfType(DataLayer.TREES)

        if hasTreeLayer:
            self.uiCallback.enableTreeLayerFieldPickers(treeLayer)        
            #if interactive:
            #    self.promptUserSetSpeciesField()

        

    
    def resetDataStore(self):
        self.dataStore.clear()
    
    def promptUserSetSpeciesField(self):        
        """
        Prompts the user to set tree genus / tree species field now. Switches to options tab if consented by user
        """

        qm = QMessageBox
        ret = qm.question(self.dlg,'', "Set tree genus/tree species field now?", qm.Yes | qm.No)
        # switch to options tab and toolbox
        if ret == qm.Yes:
            pass
            # switch to options tab
            #self.dlg.tabWidget.setCurrentIndex(1)
            

            # switch to SITA optios
            # self.dlg.toolBox.setCurrentIndex(1) 
        

    def initDataSourcesView(self):
        self.dlg.layerView.setModel(None)
        self.dataStore = SiacDataStore(QgsProject.instance(), self.uiCallback.setActiveLayerFieldText)
        self.dlg.layerView.setModel(self.dataStore.getViewModel())
        self.dlg.layerView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)


    def uiCallbackAddDataSourceToList(self):
        # this function is used as a event handler when user wants to add
        # a new layer to the model. 
        # As its manually adding a layer, it is certainly also always a new layer
        
        if (self.dlg.pickerLayerType.currentText() == ""):
            QtWrapper.showErrorMessage(self.dlg, "Select a type!")        
        else:  
            cLayer = self.dlg.pickerSelectedLayer.currentLayer()
            allLayers = QgsProject.instance().mapLayers()
        
            # iterate over datasource types and layers
            for currentLayerId, layer in allLayers.items():
                layerDisplayName = layer.name()            
                if layerDisplayName == cLayer.name():

                    # with the new flow, as this is by definition a new data source,
                    # create a new datatorelayersource item and let the store handle adding to map etc.
                    currentLayer = self.dlg.pickerSelectedLayer.currentLayer()
                    currentType = self.dlg.pickerLayerType.currentText()
                    currentName = self.dlg.pickerSelectedLayer.currentLayer().sourceName()

                    newLayerSource = SiacDataStoreLayerSource.makeNewDataStoreLayerSourceItem( currentLayer, currentType, currentName, currentLayerId )
                    self.dataStore.addDataStoreLayerSource(newLayerSource)

                    # when adding certain types of layers, perform additional actions
                    interactive = True
                    if DataLayer(currentType) == DataLayer.TREES:
                        self.uiCallback.enableTreeLayerFieldPickers(currentLayer)  
                        #if interactive:
                        #    self.promptUserSetSpeciesField()
                       
                    break

            self.uiCallback.updatePickerDataLayerTypes()
    
    ############################################################
    #
    # Init COIN tasks
    #
    ############################################################

    def runCoinTotalTreeCoverTool(self):
        """Initializes COIN Tree Cover Area assessment task
        """

        inputLayer = self.getUserSelectedLayer()           
        if inputLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
            return

        coinWorkerParams = { 
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.TREE_COVER, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [ self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD) ]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                #{ "INDICATOR" : SiacIndicator.TREE_DENSITY, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : []} },                    
            ]
        }           
        self.initCoinTask(coinWorkerParams)

    def runCoinTotalForestCoverTool(self, forestIdentificationEngine : CoinForestCoverIdentificationEngine):

        if forestIdentificationEngine == CoinForestCoverIdentificationEngine.SITE_SPECIFIC_TRAITS:
            
            inputLayer = self.getUserSelectedLayer()           
            if inputLayer is None:
                QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
                return            
            inputLayers = [ inputLayer ]
        
        elif forestIdentificationEngine == CoinForestCoverIdentificationEngine.SELF_REFERENTIAL:

            treeCoverLayer = self.dataStore.getItem(DataLayer.TREE_COVER)
            if treeCoverLayer is None:
                QtWrapper.showErrorMessage(self.dlg, "Tree input layers is missing.")
                return
            inputLayers = [ treeCoverLayer ] 

        coinWorkerParams = { 
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.FOREST_COVER, "INPUTS" :  { 'LAYERS' : inputLayers, 'PARAMS' : [ forestIdentificationEngine, self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_LINEARITY_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_NEAR_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_MINIMUM_AREA_THRESHOLD) ]} },
            ]
        }           
        self.initCoinTask(coinWorkerParams)

    def runCoinSummarizeTreeRichnessAndDiversityTool(self):
        
        inputLayer = self.getUserSelectedLayer()           
        if inputLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
            return
        
        coinWorkerParams = { 
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.TREE_SPECIES_RICHNESS, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [ self.uiCallback.getOptionValue(SiacToolkitOptionValue.TCAC_PARAMS_FRUITTREE_SPECIES_LIST) ]} },
            ]
        }           
        self.initCoinTask(coinWorkerParams)
        
        
    def runCoinCarbonStorageAndSequestrationTool(self):
        
        inputLayer = self.getUserSelectedLayer()           
        if inputLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
            return

        coinWorkerParams = { 
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.AVERAGE_CARBON_SEQUESTRATION, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [ self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_CARBON_SEQUESTRATIONRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS) ]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                { "INDICATOR" : SiacIndicator.AVERAGE_CARBON_STORAGE, "INPUTS" : { 'LAYERS' :  [ inputLayer ], 'PARAMS' : [ self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_CARBON_STORAGERATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS) ]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
            ]
        }           
        self.initCoinTask(coinWorkerParams)

    def runCoinRegulationOfAirQualityTool(self):

        inputLayer = self.getUserSelectedLayer()           
        if inputLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
            return

        coinWorkerParams = {
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.AIR_QUALITY_REMOVED_SO2, "INPUTS" : { 'LAYERS' : [ inputLayer ], 'PARAMS' : [self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_SO2_REMOVALRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS)]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                { "INDICATOR" : SiacIndicator.AIR_QUALITY_REMOVED_NO2, "INPUTS" : { 'LAYERS' : [ inputLayer ], 'PARAMS' : [self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_NO2_REMOVALRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS)]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                { "INDICATOR" : SiacIndicator.AIR_QUALITY_REMOVED_O3, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_O3_REMOVALRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS)]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                { "INDICATOR" : SiacIndicator.AIR_QUALITY_REMOVED_CO, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_CO_REMOVALRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS)]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
                { "INDICATOR" : SiacIndicator.AIR_QUALITY_REMOVED_PM10, "INPUTS" : { 'LAYERS' : [ inputLayer ], 'PARAMS' : [self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_AIR_QUALITY_PM10_REMOVALRATE), self.uiCallback.getOptionValue(SiacToolkitOptionValue.TYPOLOGY_FOREST_RELATIVE_TREE_COVER_THRESHOLD), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_MEDIATE_ESS)]}, "AGGREGATE" : [DescriptiveParameter.SUM] },
            ]
        }
        self.initCoinTask(coinWorkerParams)

    def runCoinLocalOlsRegressionTool(self):
        
        inputLayer = self.getUserSelectedLayer()                   
        if inputLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "Set active layer.")
            return
                
        containsMeanValValues = LayerHelper.containsFieldWithName( inputLayer.LayerSource, SiacField.OLS_DEPENDENT_MEAN.value )
        
        targetLayer = None
        if not containsMeanValValues:
            # check if target layer is selected, return otherwise
            targetLayer = self.dlg.pickerOlsTargetLayer.currentLayer()            
            if targetLayer is None:
                QtWrapper.showErrorMessage(self.dlg, "Please set the dependent variable layer in the COIN tool parameters.")
                return                   
            
        coinWorkerParams = {
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.LOCAL_OLS_IMPACT, "INPUTS" :  { 'LAYERS' : [ inputLayer ], 'PARAMS' : [ containsMeanValValues, LocalRegressionConverType(self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_COOLING_PREDS_COVERTYPE)), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_COOLING_INCLUDE_LOWESS), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_COOLING_PREDS_INCLUDE_IMPV), self.uiCallback.getOptionValue(SiacToolkitOptionValue.COIN_ESS_COOLING_INCLUDE_ANCILLARY_ENTITIES), targetLayer ] } }
            ]
        }
        self.initCoinTask(coinWorkerParams)

    
    def runCoinStreetTreeDensityTool(self):
        
        classifiedCadastreLayer = self.dataStore.getItem(DataLayer.CLASSIFIED_TREES)
        streetCenterlinesLayer = self.dataStore.getItem(DataLayer.STREETS)

        if classifiedCadastreLayer is None or streetCenterlinesLayer is None:
            QtWrapper.showErrorMessage(self.dlg, "One or more input layers are missing.")
            return
        
        inputLayers = [ classifiedCadastreLayer, streetCenterlinesLayer ] 

        coinWorkerParams = { 
            'REQUESTS' : [
                { "INDICATOR" : SiacIndicator.STREET_TREE_DENSITY, "INPUTS" :  { 'LAYERS' : inputLayers, 'PARAMS' : [] } },
            ]
        }           
        self.initCoinTask(coinWorkerParams)

    #####################################
    #
    # UI run 
    #
    ######################################

    def run(self):
        """Run method that is called from QGIS UI"""

        
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:            

            self.first_start = False

            self.dlg = Ui_MainWindow()
            self.uiCallback = QtUiMainDialogCallbacks(self)
            
            
            self.dlg.statusBar().addPermanentWidget(self.dlg.txtActiveLayer)
            self.dlg.statusBar().addPermanentWidget(self.dlg.statusActiveLayer)

            self.dlg.statusBar().addPermanentWidget(QLabel("TALLO"))
            self.dlg.statusBar().addPermanentWidget(self.dlg.statusTallo)
            self.dlg.statusBar().addPermanentWidget(QLabel("UT"))
            self.dlg.statusBar().addPermanentWidget(self.dlg.statusUTDB)
            self.dlg.statusBar().addPermanentWidget(self.dlg.internalProgress)

            self.dlg.statusBar().addPermanentWidget(self.dlg.labelEpsg)
 
            self.dlg.statusBar().addWidget(self.dlg.internalMessage)

            # define re-usable actions, when they should be added to both menu and toolbar
            resolve_ds_action = QAction(QIcon(':/plugins/ch_siac/assets/layers.png'), "&Resolve Data Sources", self.dlg)
            resolve_ds_action.setStatusTip('Attempt to assign map layers to tool data layer types')
            resolve_ds_action.setShortcut('Shift+Ctrl+R')
            resolve_ds_action.triggered.connect(self.resolveDataSources)

            self.uiCallback.open_ancillary_data_editor_action = QAction(QIcon(':/plugins/ch_siac/assets/editlayers.png'), "&Ancillary data editor", self.dlg)
            self.uiCallback.open_ancillary_data_editor_action.setStatusTip('Open ancillary data editor to define ancillary classes/entities')
            self.uiCallback.open_ancillary_data_editor_action.setShortcut('Shift+Ctrl+A')
            self.uiCallback.open_ancillary_data_editor_action.triggered.connect(self.uiCallback.initAncillaryDataEditorFromSelectedLayer)

            clear_tool_log_action = QAction(QIcon(':/plugins/ch_siac/assets/cleaning.png'), "Clear tool log", self.dlg)
            clear_tool_log_action.setStatusTip('Clear Tool log')
            clear_tool_log_action.triggered.connect(self.uiCallback.clearToolLog)

            # font_inc_action = QAction(QIcon(':/plugins/ch_siac/assets/font_increase.png'), "Increase font size", self.dlg)
            # font_inc_action.setStatusTip('Increase font size')
            # font_inc_action.triggered.connect(self.uiCallback.increaseLogFontSize)
            # font_dec_action = QAction(QIcon(':/plugins/ch_siac/assets/font_decrease.png'), "Decrease font size", self.dlg)
            # font_dec_action.setStatusTip('Decrease font size')
            # font_dec_action.triggered.connect(self.uiCallback.decreaseLogFontSize)

            
            
            
            
            # add toolbar
            toolbar = QToolBar('Main ToolBar')
            self.dlg.addToolBar(toolbar)
            toolbar.setIconSize(QSize(24, 24))

            toolbar.addAction(resolve_ds_action)
            toolbar.addAction(self.uiCallback.open_ancillary_data_editor_action)
            toolbar.addSeparator()
            #toolbar.addAction(font_inc_action)
            #toolbar.addAction(font_dec_action)
            toolbar.addAction(clear_tool_log_action)





            # always stay on top?
            # #self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)

            # # initialize data view table
            self.initDataSourcesView()
            
            # define callback handlers, default ui states etc.              
            self.uiCallback.setupUiAtFirstStart(self.params['OPTIONS'])
            
            # self.createMapTools()

            # Populate model menu
            self.dlg.menuFile.addAction("Load Model", self.loadModel)
            self.dlg.menuFile.addAction("Save Model", self.saveModel)
            self.dlg.menuFile.addSeparator()
            self.dlg.menuFile.addAction("Update Project CRS from Map Canvas", self.uiCallback.setProjectCrs)
            self.dlg.menuFile.addSeparator()
            self.dlg.menuFile.addAction(resolve_ds_action)
            #self.dlg.menuFile.addAction("&Resolve Data Sources", self.resolveDataSources, QKeySequence("Shift+Ctrl+R"))
            self.dlg.menuFile.addAction("Remove All", self.uiCallback.btnRemoveAllRowsClickEventHandler)
            self.dlg.menuFile.addSeparator()
            importDbsMenu = self.dlg.menuFile.addMenu('&Import')
            importDbsMenu.addAction("&Tallo Database", partial(self.importExternalDatabase, SiacToolkitDataType.TALLO_DB))
            importDbsMenu.addAction("&Urban Tree Database", partial(self.importExternalDatabase, SiacToolkitDataType.URBAN_TREE_DB))
            self.dlg.menuFile.addSeparator()
            self.uiCallback.exportMenu = self.dlg.menuFile.addMenu('&Export')           
            self.uiCallback.exportMenu.aboutToShow.connect(self.uiCallback.aboutToShowExportMenu)

            # TCAC   
            tcac_menu = self.dlg.menuTools.addMenu("&TCAC")          
            tcac_menu.addAction('Model Tree &Cover', partial(self.initTcacTask, TcacTask.MODEL_TREE_COVER), QKeySequence("Ctrl+T")) 
            tcac_menu.addAction('Asssess &Tree Configuration and Richness', partial(self.initTcacTask, TcacTask.TREE_PATTERN_ASSESSMENT_AND_CLASSIFICATION)) 
            tcac_menu.addSeparator()
            tcac_averageTcMenu = tcac_menu.addMenu('Trait &Modelling')
            tcac_averageTcMenu.addAction('From &TALLO', partial(self.initTcacTask, TcacTask.MODEL_TRAITS_FROM_TALLO))
            tcac_averageTcMenu.addAction('From &Urban Tree Database', partial(self.initTcacTask, TcacTask.MODEL_TRAITS_FROM_UTDB))

            # TOPOMOD menu
            topomod_btn_menu = self.dlg.menuTools.addMenu('TO&POMOD')
            topomod_btn_menu.addAction('Model &Spatial Relationships and Topology', partial(self.initTopomodTask, TopomodTask.COMPUTE_TOPOLOGY))
            
            # Connectivity menu as TOPOMOD submenu
            connectivity_btn_menu = topomod_btn_menu.addMenu('Model Structural &Connectivity')
            connectivity_btn_menu.addAction('Generate &nearest neighbours network', partial(self.initTopomodTask, TopomodTask.COMPUTE_NEAREST_NEIGHBOUR_NETWORK), QKeySequence("Ctrl+N"))
            connectivity_btn_menu.addSeparator()
            connectivity_btn_menu.addAction('Model &Structural Connectivity', partial(self.initTopomodTask, TopomodTask.COMPUTE_CONNECTIVITY), QKeySequence("Ctrl+S"))     
            connectivity_btn_menu.addAction('Model &Fragmentation', partial(self.initTopomodTask, TopomodTask.ASSESS_FRAGMENTATION))                   
            
            # SITA
            sita_btn_menu = self.dlg.menuTools.addMenu('&SITA')
            sita_btn_menu.addAction('Assess Plots', partial(self.initSitaTask, SitaTask.ITERATE_PLOTS),  QKeySequence("Ctrl+P"))
            sita_btn_menu.addAction('Assess Randomly Sampled Locations', partial(self.initSitaTask, SitaTask.ITERATE_SAMPLED_LOCATIONS))            

            # COIN menu
            coin_btn_menu = self.dlg.menuTools.addMenu('&COIN')             
            coin_btn_menu.addAction('Total tree cover', self.runCoinTotalTreeCoverTool)
            coin_btn_menu.addAction('Street tree density', self.runCoinStreetTreeDensityTool)

            forestCoverMenu = coin_btn_menu.addMenu('Total forest cover')
            forestCoverMenu.addAction('Plot-dependent (Top-Down)', partial(self.runCoinTotalForestCoverTool, CoinForestCoverIdentificationEngine.SITE_SPECIFIC_TRAITS))
            forestCoverMenu.addAction('Geometry-derived (Bottom-up)', partial(self.runCoinTotalForestCoverTool, CoinForestCoverIdentificationEngine.SELF_REFERENTIAL))
            
            coin_btn_menu.addAction('Summarize Tree Richness and Diversity', self.runCoinSummarizeTreeRichnessAndDiversityTool)
            coin_btn_menu.addAction('Carbon Sequestration and Storage', self.runCoinCarbonStorageAndSequestrationTool)
            coin_btn_menu.addAction('Regulation of air quality', self.runCoinRegulationOfAirQualityTool)
            coin_btn_menu.addAction('Local OLS Regression', self.runCoinLocalOlsRegressionTool)

             # Populate tools menu            
            # DATA PROCESSOR submenu
            self.dlg.menuTools.addSeparator()
            dw_btn_menu = self.dlg.menuTools.addMenu('&Pre-Processing')
            dw_btn_menu.addAction("Model Street Morphology", partial(self.initDataProcessorTask, DataProcessorTask.COMPUTE_STREET_MORPHOLOGY))
            dw_btn_menu.addAction("Model Plots using Enclosed Tessellation", partial(self.initDataProcessorTask, DataProcessorTask.COMPUTE_CLOSED_TESSELLATION))
            

            self.dlg.menuView.addSeparator()
            self.dlg.menuView.addAction("Save Log to File", self.uiCallback.saveToolLog)
            self.dlg.menuView.addAction(clear_tool_log_action)

            # connect help etc.
            # this will simply print an about etc. to the console
            self.dlg.menuHelp.addAction("Open Documentation", partial(self.uiCallback.getHelp, os.path.dirname(__file__)))  
            self.dlg.menuHelp.addAction("About SIAC", self.uiCallback.printToolStatement)  

        # this is required for momepy if verbose set to True in tools
        # show console in any case
        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():
            console.show_console()
        

        # show the dialog
        self.dlg.show()        
